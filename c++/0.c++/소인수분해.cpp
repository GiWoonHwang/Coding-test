/*
소인수분해란 어떤 수를 소수들의 곱으로 표현하는 것입니다. 예를 들어 12를 소인수 분해하면 2 * 2 * 3 으로 나타낼 수 있습니다. 따라서 12의 소인수는 2와 3입니다. 자연수 n이 매개변수로 주어질 때 n의 소인수를 오름차순으로 담은 배열을 return하도록 solution 함수를 완성해주세요.

제한사항
2 ≤ n ≤ 10,000
입출력 예
n	    result
12	    [2, 3]
17	    [17]
420	    [2, 3, 5, 7]
입출력 예 설명
입출력 예 #1

12를 소인수분해하면 2 * 2 * 3 입니다. 따라서 [2, 3]을 return합니다.
입출력 예 #2

17은 소수입니다. 따라서 [17]을 return 해야 합니다.
입출력 예 #3

420을 소인수분해하면 2 * 2 * 3 * 5 * 7 입니다. 따라서 [2, 3, 5, 7]을 return합니다.
*/

// 배열을 하나 선언한 후 입력받은 값을 2부터 나누어준다. result값이 중복되면 안되기 때문에 배열에 값이 없으면 append 해준다.
// 그 후 나누는 값을 더 해줌 

#include <string>
#include <vector>
#include <algorithm>
using namespace std;

vector<int> solution(int n){
    vector<int> answer;
    int value = 2;

    while(n > 1){
        if(n % value ==0){
            /*
            push_back은 객체를 삽입하기 위해서 똑같은 임시 객체를 하나 더 만들어서 거기에 복사한 다음 벡터에 삽입 -> 삽입이 끝나면 임시 객체 파괴 -> 잠깐 쓰고 버릴 메모리를 굳이 할당해 줘야 함. 임시 객체 생성자를 호출해서 생성하고 소멸자를 불러서 파괴시키는 과정에서 불필요한 연산이 생긴다. => 다소 비효율적
            emplace_back은 가변인자 템플릿을 사용해서 삽입하려는 자료형에 따라 함수 내에서 삽입을 위한 객체를 자체 생성할 수 있다 -> 즉 똑같은 임시 객체를 만들 필요가 없다 -> 파괴해야 할 임시 객체 자체가 생기지 않는다 -> 잠깐 쓰고 버릴 메모리를 할당할 필요가 없다. => push_back에 비해 효율적 
            */
            answer.emplace_back(value);
            /*
            여기서 while문을 사용해야 하는 이유를 모르겠다. 이 구문을 안쓰면 시간초과함 -> 수정: n = 12, value = 2라고 가정했을 때, 2는 이미 12의 소인수이다. 하지만 결과값의 배열은 중복을 허용하지 않는다. 따라서 첫 번 째
            소인수인 2로 계속 나누어 나머지가 존재하는 값이 나오면 이제 value값을 추가해서 다시 소인수인지 판단해야한다. while구문이 없으면 vector에는 중복값이 들어가게 된다.
            */ 
            while(n%value == 0){ 
                n/=value;
            }

        }
        value++;

    }
    return answer;
}













