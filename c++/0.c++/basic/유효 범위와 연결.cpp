/*
유효 범위 
유효범위란 하나의 변환 단위 내에서 해당 변수가 사용될 수 있는 범위를 나타낸다.
함수 내에서 선언된 변수는 함수 내에서만 사용할 수 있다. 또한 함수 밖에서 선언된 변수는 변수가 선언된 이후에 나오는 모든 함수에서 사용할 수 있다.

연결
연결이란 해당 변수를 사용할 수 있는 파일의 접근 가능 여부를 나타낸다.
외부 연결을 가지는 변수는 여러 파일에서 사용할 수 있다. 하지만 내부 연결을 가지는 변수는 하나의 파일에서만 사용할 수 있다.
또한, 함수 내에서 선언된 변수는 함수 밖에서는 사용할 수 없으므로 연결을 가지지 않는다.

cpp 변수의 종류
cpp에서 변수는 유효한 범위, 연결 등을 기준으로 다음과 같이 나눌 수 있다.
1. 자동 변수
2. 레지스터 변수
3. 정적 변수
*/

#include <iostream>
using namespace std;

/*
자동 변수란 블록 내에서 선언된 변수를 의미하며, 함수의 매개변수도 여기에 포함됩니다.

이러한 자동 변수는 변수가 선언된 블록 내에서만 유효하며, 블록이 종료되면 메모리에서 사라집니다.

자동 변수는 메모리상의 스택(stack) 영역에 저장되며, 초기화하지 않으면 의미 없는 값(쓰레깃값)으로 초기화됩니다.

이러한 자동 변수는 C언어의 지역 변수(local variable)와 같은 의미로 사용됩니다.
*/
void Local(void); 

int main(void){
    int i = 5;
    int var = 10;
    cout << "main() 함수 내의 자동 변수 var의 값은 " << var << "입니다." << endl; // main() 함수 내의 자동 변수 var의 값은 10입니다.

    if (i < 10){
        Local();
        int var = 30;
        cout << "if 문 내의 자동 변수 var의 값은 " << var << "입니다." << endl; // if 문 내의 자동 변수 var의 값은 30입니다.
    }
    cout << "현재 자동 변수 var의 값은 " << var << "입니다." << endl; // 현재 자동 변수 var의 값은 10입니다.
    return 0;
} 

void Local(void){
    int var = 20;
    cout << "Local() 함수 내의 자동 변수 var의 값은 " << var << "입니다." << endl; // Local() 함수 내의 자동 변수 var의 값은 20입니다.
}

/*
위의 예제에서 변수 var는 한 번은 main() 함수 내에서, 또 한 번은 if문에서, 마지막은 local()함수내에서 선언된다.
이처럼 같은 이름의 변수 var는 모두 다른 중괄호 ({}) 영역에서 선언되었으며, 이러한 중괄호 영역을 블록(block)이라고 한다.
이렇게 변수의 유효 범위는 변수가 선언된 블록을 기준으로 설정되며, 해당 블록이 끝나면 모든 장동 변수는 메모리에서 사라지게 된다.
*/

/*
레지스터 변수
레지스터 변수란 변수를 선언할 때 register키워드를 붙여 선언한 변수를 의미한다.
c언어에서 이렇게 선언한 레지스터 변수는 cpu의 레지스터메모리에 저장되어 빠르게 접근할 수 있게 된다.
하지만 컴퓨터의 레지스터는 매우 작은 크기의 메모리이므로, 이 영역에 변수를 선언하기 힘든 경우도 많다.
그럴때 c컴파일러는 해당 변수를 그냥 지역변수로 선언하게 된다.
cpp 11부터는 단순히 해당 변수가 자동 변수라는 것을 의미하는 역할로만 사용되고 있습니다.
*/

/*
정적 변수
cpp에서 정적변수는 프로그램이 실행되는 내내 유지되는 변수를 의미한다.
이러한 정적 변수는 메모리상의 데이터 영역에 저장되며, 초기화핮지 않으면 0으로 자동 초기화왼다.
cpp에서는 다음과 같이 세 가지 유형의 정적 변수를 제공하고 있다.

1. 연결을 가지지 않는 정적 변수
2. 내부 연결을 가지는 정적 변수
3. 외부 연결을 가지는 정적 변수
*/


/*
연결을 가지지 않는 정적 변수
연결을 가지지 않는 정적 변수는 블록 내부에서 static 키워드를 사용하여 정의한다. 이러한 연결을 가지지 않는 정적 변수는 지역 변수와 전역 변수의 특징을 모두 가지게 된다.
이 변수는 전역 변수처럼 단 한번만 초기화되며, 프로그램이 종료되어야 메모리상에서 사라진다. 또한, 이렇게 선언된 변수는 지역변수처럼 해당 블록 내에서만 접근할 수 있다.
*/

void Local(void);
void StaticVar(void);

int main(void){
    for(int i=0; i<3; i ++){
        Local();
        StaticVar();
    }
    return 0;
}

void Local(void){

    int count = 1;

    cout << "Local() 함수가 " << count << " 번째 호출되었습니다." << endl;

    count++;

}

void StaticVar(void){

    static int static_count = 1; // 연결을 가지지 않는 정적 변수

    cout << "StaticVar() 함수가 " << static_count << " 번째 호출되었습니다." << endl;

    static_count++;

}

/*
Local() 함수가 1 번째 호출되었습니다.

StaticVar() 함수가 1 번째 호출되었습니다.

Local() 함수가 1 번째 호출되었습니다.

StaticVar() 함수가 2 번째 호출되었습니다.

Local() 함수가 1 번째 호출되었습니다.

StaticVar() 함수가 3 번째 호출되었습니다.

지역 변수인 count는 함수의 호출이 끝날 때마다 메모리에서 사라진다. 
하지만 연결을 가지지 않는 정적 변수인 static_count는 함수의 호출이 끝나도 메모리상에서 사라지지 않는다.
그러므로 다음 함수 호출 때에도 이전의 데이터를 그대로 저장되고 있다. 또한, static_count는 전역 변수와는 달리 자신이 선언된 StaticVar() 함수 이외의
영역에서는 호출할 수 없다.
*/


/*
내부 연결을 가지는 정적 변수
내부 연결을 가지는 정적 변수는 유효 범위를 변환 단위로 가지는 변수에 static 키워드를 사용하여 정의한다.
이러한 내부 연결을 가지는 정적 변수는 해당 변수를 포함하고 있는 변환 단위, 즉 현재 파일에서만 사용하고 있다.
이 변수는 하나의 파일 내의 모든 블록에서 접근할 수 있고, 또한 사용할 수 있다.
*/

static int var; // 내부 연결을 가지는 정적 변수

void Local(void); 

int main(void){

    cout << "변수 var의 초깃값은 " << var <<"입니다." << endl; // 0

    int i = 5;

    int var = 10; // 자동 변수 선언

    cout << "main() 함수 내의 자동 변수 var의 값은 " << var <<"입니다." << endl; // 10

    if (i < 10){
        Local(); // 20
        cout << "현재 변수 var의 값은 " << var << "입니다." << endl; // 자동 변수에 접근 10
    }

    cout << "더 이상 main() 함수에서는 정적 변수 var에 접근할 수가 없습니다." << endl;
    return 0;
} 

void Local(void){
    var = 20; // 정적 변수의 값 변경
    cout << "Local() 함수 내에서 접근한 정적 변수 var의 값은 " << var << "입니다." << endl;

}

/*
변수 var의 초기값은 0입니다.

main() 함수 내의 자동 변수 var의 값은 10입니다.

Local() 함수 내에서 접근한 정적 변수 var의 값은 20입니다.

현재 변수 var의 값은 10입니다.

더 이상 main() 함수에서는 정적 변수 var에 접근할 수가 없습니다.

위는 예제에서 정벽 변수 var와 같은 이름의 자동 변수 var가 main()함수 내부에서 선언된다.
이 자동 변수가 선언되기 전까지는 main()함수에서도 정적 변수 var에 접근할 수 있다.
하지만 자동 변수 var가 선언된 후에는 main()함수에서 정적변수 var로 접근할 방법이 없어진다. 왜냐하면, 블록 내에서 선언된 자동 변수는 같은 이름의 정적 변수를 덮어쓰기 때문이다.

C++에서는 하나의 파일 내의 모든 블록에서 데이터를 공유하기 위한 또 다른 방법으로 네임스페이스를 제공하고 있습니다.

C++ 네임스페이스에 대한 더 자세한 사항은 C++ 네임스페이스 수업에서 확인할 수 있습니다.
*/

/*
외부 연결을 가지는 정적 변수
외부 연결을 가지는 정적 변수는 유효 범위를 변환 단위로 가지는 변수를 의미합니다.

이러한 외부 연결을 가지는 정적 변수를 전역 변수(global variable) 또는 외부 변수(extern variable)라고 합니다.

 

외부 변수는 해당 파일뿐만 아니라 외부 파일에서도 사용할 수 있는 변수입니다.

이러한 외부 변수는 해당 변수를 사용하는 모든 파일에서 각각 extern 키워드를 사용하여 재선언되어야 사용할 수 있습니다.

파일1.cpp
#include <iostream>

using namespace std;

 

int var = 10; // 외부 변수 정의

...

파일2.cpp
#include <iostream>

using namespace std;

 

#include "파일1.cpp"

extern int var; // 외부 변수를 사용하기 위한 재선언

...

변수의 종류
변수 종류	                   유효 범위	연결	선언 위치	키워드
자동 변수	                   블록	        없음	블록 내부	없음
레지스터 변수	               블록	        없음	블록 내부	register
연결을 가지지 않는 정적 변수	블록         없음	 블록 내부	 static
내부 연결을 가지는 정적 변수	변환 단위	 내부	 함수 외부	 static
외부 연결을 가지는 정적 변수	변환 단위	 외부	 함수 외부	 없음
*/