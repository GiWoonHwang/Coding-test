/*
배열이란 같은 타입의 변수들로 이루어진 유한 집합으로 정의할 수 있습니다.
배열을 구성하는 각각의 값을 배열 요소라고 하며, 배열에서의 위치를 가리키는 숫자를 인덱스 라고 합니다.
cpp에서 인덱스는 언제나 0부터 시작하며, 0을 포함한 양의 정수만을 가질 수 있습니다.
배열은 같은 종류의 데이터를 많이 다뤄야 하는 경우에 사용할 수 있는 가장 기본적인 자료구조입니다.
배열은 선언되는 형식에 따라 1차원 배열, 2차원 배열뿐만 아니라 그 이상의 다차원 배열로도 선언할 수 있습니다.
하지만 현실적으로 이해하기가 쉬운 2차원 배열까지가 많이 사용됩니다.

1차원 배열
타입 배열이름[배열길이];
타입은 배열 요소로 들어가는 변수의 타입을 명시합니다.
배열 이름은 배열이 선언된 후에 배열에 접근하기 위해 사용됩니다.
배열의 길이는 해당 배열이 몇 개의 배열 요소를 가지게 되는지 명시합니다.
열은 선언만 하고 초기호 하지 않으면, 모든 배열 요소가 쓰레깃값으로 채워집니다.
배열의 이름은 언제나 배열의 첫 번째 요소와 같은 주소를 가리키고 있습니다.

배열의 특징
c++에서 배열은 다음과 같은 특징을 가집니다.
1. 배열의 길이를 선언할 때에는 반드시 상수를 사용해야 한다.
2. 배열 요소의 인덱스는 언제나 0부터 시작합니다.
3. c++ 컴퍼일러는 배열의 길이를 전혀 신경 쓰지 않습니다.

배열이 차지하는 메모리의 크기
c++에서 배열을 복사하거나 배열 요소에 특정 작업을 하고 싶을 때 해당 배열이 차지하는 메모리의 크기를 정확히 알고 있는 것이 좋습니다.
배열이 차지하는 총 메모리의 크기는 다음 수식을 사용하여 구할 수 있습니다.
배열이 차지하는 메모리의 크기 = 배열의 크기 x sizeof(타입)

그리고 배열의 길이를 알고 싶을 때에는 다음 수식을 사용하여 구할 수 있습니다.
배열의 길이 = sizeof(배열 이름) / sizeof(배열이름[0]) 
위의 수식에서 배열 이름[0]은 해당 배열의 타입을 나타내기 위해서 사용되었다.

narrowing cast
이전 버전의 c++에서 발생하던 수많은 호환성 문제를 c++11 에서는 초기화 리스트를 사용하여 방지할 수 있습니다.
c++ 11에서는 초기화 리스트를 사용하여 변수나 배열을 초기화 할 경우에 narrowing cast를 허용하지 않습니다.

int var = 3.14; // narrowing cast
위의 예제는 int형 변수를 실숫값으로 초기화함으로써 데이터의 손실이 발생합니다.
이렇게 데이터의 손실이 발생하는 암시적인 타입 변환을 narrowing cast라고 합니다.

int var = {3.14}; // 초기화 리스트를 통한 narrowing cast는 허용하지 않으므로, 경고를 발생시킴.
*/

#include <iostream>
using namespace std;

int main(){
    int sum = 0;
    int grade[3]; // 길이가 3인 int형 배열 선언

    // 인덱스를 이용한 배열의 초기화
    grade[0] = 85; // 국어 점수
    grade[1] = 65; // 영어 점수
    grade[2] = 90; // 수학 점수

    for(int i = 0; i < 3; i++){
        sum += grade[i];
    }

    cout << "국여수 과목 총 점수 합계는" << sum << "점이고, 평균 점수는" << (double)sum/3 << "점 입니다." << endl;

    /*
    c++에서는 변수와 마찬가지로 배열도 선언과 동시에 초기화 할 수 있다.
    다음과 같이 괄호({})를 사용하여 초깃값을 나열한 것을 초기화 리스트라고 한다
    타입 배열이름[배열길이] = {배열요소1, 배열요소2 ..}
    단 초기화 리스트의 타입과 배열의 타입은 반드시 일치해야 합니다.
    만약 초기화 리스트의 개수가 배열의 총 길이보다 적으면, 배열의 앞에서부터 차례대로 초기화 될 것이다.
    이때 초기화되지 못한 나머지 배열 요소는 모두 0으로 초기화된다.
    하지만 초기화 리스트를 이용한 초기화 방식은 반드시 배열의 선언과 함께 정의되어야 한다.
    배열이 먼저 선언된 후에는 이 방식으로 배여르이 요소를 초기화 할 수 없다.
    */
   int arr1[3] = {0,1,2}; // 배열의 선언과 동시에 초기화는 가능함
   int arr2[3]; // 배열의 선언
//    arr2[3] = {0,1,2}; // 배열이 먼저 선언된 후에는 이 방식으로 초기화 될 수 없음
//    arr2 = arr1; // 길이가 같더라도 하나의 배열을 다른 배열에 통째로 대입할 수는 없음

    // 배열의 길이 자동설정: cpp에서는 초기화 리스트에 맞춰 자동으로 배열의 길이를 설정할 수도 있다.
    int arr[] = {1,2,3}; // int형 배열 arr의 길이는 자동으로 3으로 설정됨과 동시에 초기화 리스트에 의해 초기화됨
    
    int sum      = 0;
    int grade[3] = {85,65,90};
    grade[3]     = 100;  // grade[3]을 선언하지 않고 초기화 진행 

    for (int i = 0; i < 4; i ++){
        sum += grade[i];
    }
    // 존재하지도 않는 grade[3]이라는 배열 요소의 초기화를 진행하고 반복문을 통해 수식에서도 이용하는 예기치 않은 오류 발생
    cout << "국영수 과목 총 점수 합계는 " << sum << "점이고 평균 점수는" << (double)sum/3 << "점 입니다" << endl;
    
    int grade[] = {85, 65, 90};                 // 배열의 길이를 명시하지 않음
    int len = sizeof(grade) / sizeof(grade[0]); // 배열의 길이를 구하는 공식
    cout << "배열 grade의 길이는 " << len << "입니다.";
    
    
    
    return 1;
}