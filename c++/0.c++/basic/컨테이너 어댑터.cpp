/*
컨테이너 어댑터란 기존 컨테이너의 인터페이스를 제한하여 만든 기능이 제한되거나 변형된 컨테이너를 의미한다.
*/

/*
스택
스택 컨테이너는 벡터 클래스의 인터페이스

스택(stack) 컨테이너는 vector 클래스의 인터페이스를 제한하여, 전형적인 스택 메모리 구조의 인터페이스를 제공합니다.

스택 컨테이너는 stack 헤더 파일에 정의되어 있습니다.

 

스택 메모리 구조는 선형 메모리 공간에 데이터를 저장하면서 후입선출(LIFO)의 시멘틱을 따르는 자료 구조입니다.

즉, 가장 나중에 저장된(push) 데이터가 가장 먼저 인출(pop)되는 구조입니다.

 

stack container

 

스택 컨테이너는 스택 메모리 구조를 표현하기 위해 다음과 같은 멤버 함수를 제공합니다.

멤버 함수	설명
empty()	스택이 비어 있으면 true를, 비어 있지 않으면 false를 반환함.
size()	스택 요소의 총 개수를 반환함.
top()	스택의 제일 상단에 있는(제일 마지막으로 저장된) 요소에 대한 참조를 반환함.
push()	스택의 제일 상단에 요소를 삽입함.
pop()	스택의 제일 상단에 있는 요소를 삭제함.
 

다음 예제는 스택 컨테이너를 사용하여 10진수를 2진수로 변환하는 예제입니다.
*/

#include <stack>
using namespace std;

int decimal = 123;

stack<int> st;

 

// 10진수를 2진수로 변환

do {

    st.push(decimal % 2);

    decimal /= 2;

} while(decimal);

 

// 스택의 모든 요소를 인출

while(!st.empty())

{

    cout << st.top();

    st.pop();

}

/*
큐(queue) 컨테이너는 deque 클래스의 인터페이스를 제한하여, 전형적인 큐 메모리 구조의 인터페이스를 제공합니다.

큐 컨테이너는 queue 헤더 파일에 정의되어 있습니다.

 

큐 메모리 구조는 선형 메모리 공간에 데이터를 저장하면서 선입선출(FIFO)의 시멘틱을 따르는 자료 구조입니다.

즉, 가장 먼저 저장된(push) 데이터가 가장 먼저 인출(pop)되는 구조입니다.

 

queue container

 

큐 컨테이너는 큐 메모리 구조를 표현하기 위해 다음과 같은 멤버 함수를 제공합니다.

멤버 함수	설명
empty()	큐가 비어 있으면 true를, 비어 있지 않으면 false를 반환함.
size()	큐 요소의 총 개수를 반환함.
front()	큐의 맨 앞에 있는(제일 먼저 저장된) 요소에 대한 참조를 반환함.
back()	큐의 맨 뒤에 있는(제일 나중에 저장된) 요소에 대한 참조를 반환함.
push()	큐의 맨 뒤에 요소를 삽입함.
pop()	큐의 맨 앞의 요소를 삭제함.
*/
int n = 20;  // 20개의 피보나치 수열을 출력함.

queue<int> que;

que.push(0); // 초깃값인 0과 1을 저장함.

que.push(1);

 

// 피보나치 수열

for(int i = 2; i < n; i++)

{

    int temp = que.front();

    cout << temp << " ";

    que.pop();

    que.push(temp + que.front());

}

/*
우선순위 큐
우선순위 큐(priority_queue) 컨테이너는 큐와는 달리 큐의 맨 앞의 요소로 가장 먼저 저장된 요소가 아닌, 가장 큰 값을 지닌 요소가 위치하게 됩니다.

또한, 큐가 deque 클래스를 기반으로 하는 것과는 달리, 우선순위 큐는 vector 클래스를 기반으로 합니다.

 

하지만 사용할 수 있는 멤버 함수는 큐 컨테이너와 같습니다.

우선순위 큐 컨테이너는 queue 헤더 파일에 정의되어 있습니다.
*/