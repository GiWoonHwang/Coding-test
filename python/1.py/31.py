# 비밀지도
# 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.
# 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 공백(" ") 또는 벽("#") 두 종류로 이루어져 있다.
# 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 "지도 1"과 "지도 2"라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
# "지도 1"과 "지도 2"는 각각 정수 배열로 암호화되어 있다.
# 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.
# 입력형식: 입력으로 지도의 한 변 크키 n과 2개의 정수 배열 arr, arr2가 들어온다.
# 1<= n <=16
# arr1, arr2는 길이 n인 정수 배열로 주어진다.
# 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.

'''
01001 = 9
10100 = 20
10010 = 18
01011 = 11
arr1 = [9,20,28,18,11]

11110 = 30
00001 = 1
10101 = 21
10001 = 17
11100 = 28
arr2 = [30,1,21,17,28]

출력
["#####", # # #, ### #,#  ##, #####]
'''
# 문제풀이
# 1. 두 지도를 이진수로 변환
# 2. 두 지도를 합침
# 3. 지도에 값에 맞게 공백 또는 #으로 바꿔줌

n = 5 # 변의 길이
answer = []
arr1 = [9,20,28,18,11]
arr2 = [30,1,21,17,28]

# 2진수로 바꿔주면 앞에 ob라는 값이 뜬다. 따라서 [2:~]부터 시작해줘야 한다.
# n이 5이고 만약 배열의 특정값에 대한 2진수가 5자리가 아닐수도 있으니 zfill로 채워줌
# 만약 00001 과 11110이 있을 때 지도가 합쳐지면 11111이 출력되어야 하기 때문에 or 연산자를 사용한다.
# print(answer.append(bin(arr1[1] or arr2[1][2:0].zfill(n)))) # 출력값 0b10100

def cal(n,arr1,arr2):
    answer = []
    for i in range(n):
        answer.append(bin(arr1[i] | arr2[i])[2:].zfill(n))
        print(answer)
    answer[i] = answer[i].replace('0'," ")
    answer[i] = answer[i].replace('1',"#")
    
    return answer

# print(list['ob11111' and 'ob10101'])
# print(list[11110 | 10101])
